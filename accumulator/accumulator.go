package accumulator

import (
	"fmt"
	"bytes"
	"math/big"
	"crypto/rand"
	"crypto/sha256"
	"crypto/rc4"
)

const RSA_2048_STR = "2519590847565789349402718324004839857142928212620403202777713783604366202070" +
"7595556264018525880784406918290641249515082189298559149176184502808489120072" +
"8449926873928072877767359714183472702618963750149718246911650776133798590957" +
"0009733045974880842840179742910064245869181719511874612151517265463228221686" +
"9987549182422433637259085141865462043576798423387184774447920739934236584823" +
"8242811981638150106748104516603773060562016196762561338441436038339044149526" +
"3443219011465754445417842402092461651572335077870774981712577246796292638635" +
"6373289912154831438167899885040445364023527381951378636564391212010397122822" +
"120720357"

type RsaAccumulator struct {
	modulus big.Int
	value big.Int
}

func (a *RsaAccumulator) initialize() {
	modulus = new(big.Int)
}




var rsa_2048 = new(big.Int)
fmt.Sscan(RSA_2048_STR, rsa_2048)


func hashToPrime(m []byte, bits int) *big.Int {
	b := make([]byte, ((bits + 7) / 8)*80)
	sum := sha256.Sum256(m)
	c, err := rc4.NewCipher(sum[:])
	c.XORKeyStream(b, b)
	p, err := rand.Prime(bytes.NewReader(b), bits)
	if err != nil {
		return nil
	}
	return p
}


